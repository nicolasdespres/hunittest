#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
#
# Copyright (c) 2015, Nicolas Desprès
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.

# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""User friendly command line interface for unittest.
"""

import sys
import argparse
import os
import pkgutil
import re
from importlib import import_module
import unittest
import operator
from pprint import pprint
import time
from enum import Enum
from collections import namedtuple
import fnmatch
import functools
import itertools
from textwrap import dedent
import subprocess

# Add trip's package directory in the path.
if os.environ.get("HUNITTEST_FROM_SOURCE", None):
    bin_dir = os.path.dirname(os.path.realpath(__file__))
    root_dir = os.path.join(bin_dir, "..")
    root_dir = os.path.normpath(os.path.realpath(root_dir))
    sys.path.insert(0, root_dir)
    del bin_dir, root_dir

from hunittest.line_printer import LinePrinter
from hunittest.unittest_result import HTestResult

try:
    import argcomplete
except ImportError:
    sys.stderr.write("info: you can get shell completion by installing "
                     "'argcomplete'")
    ARGCOMPLETE_ENABLED = False
else:
    ARGCOMPLETE_ENABLED = True

def pyname_join(seq):
    return ".".join(seq)

class RuleOperator(Enum):
    include = "+"
    exclude = "-"

class Rule(namedtuple("BaseRule", ("operator", "pattern"))):

    def __new__(cls, operator=None, pattern=None):
        if not isinstance(operator, RuleOperator):
            raise TypeError("must be a rule operator, not {}"
                            .format(type(operator).__name__))
        if not pattern:
            raise ValueError("pattern cannot be empty")
        try:
            re.compile(pattern)
        except re.error:
            raise ValueError("invalid pattern '{}': {}"
                             .format(pattern, str(e)))
        return super(Rule, cls).__new__(cls, operator, pattern)

    @property
    def include(self):
        return self.operator is RuleOperator.include

    @property
    def exclude(self):
        return self.operator is RuleOperator.exclude

    def __str__(self):
        return "{} /{}/".format(self.operator.value, self.pattern)

    def match(self, string):
        # print("STRING", repr(string))
        if re.search(self.pattern, string):
            if self.include:
                r = True
            elif self.exclude:
                r = False
            else:
                raise RuntimeError("unsupported rule operator: {}"
                                   .format(self.operator))
        else:
            if self.include:
                r = False
            elif self.exclude:
                r = True
            else:
                raise RuntimeError("unsupported rule operator: {}"
                                   .format(self.operator))
        # print("apply rule {} on {} => {}".format(self, string, r))
        return r

    def __repr__(self):
        return "{}({}, {!r})"\
            .format(type(self).__name__,
                    str(self.operator),
                    self.pattern)

class FilterRules(object):

    def __init__(self, rules=None):
        self._rules = []
        self.include_everything()
        self.exclude_nothing()
        if rules is None:
            rules = []
        for rule in rules:
            self.append(rule)

    def append(self, rule):
        self._rules.append(rule)

    def include_pattern(self, pattern):
        self.append(Rule(RuleOperator.include, pattern))

    def include_prefix(self, prefix):
        self.include_pattern(r"^{}".format(prefix))

    def include_everything(self):
        self.include_pattern(r"^.*$")

    def exclude_pattern(self, pattern):
        self.append(Rule(RuleOperator.exclude, pattern))

    def exclude_prefix(self, prefix):
        self.exclude_pattern(r"^{}".format(prefix))

    def exclude_nothing(self):
        self.exclude_pattern(r"nothing^")

    def __iter__(self):
        return iter(self._rules)

    def __call__(self, iterable, key=None):
        # print("FILTERRULE ON", repr(iterable))
        def matcher(rule, item):
            # print("ITEM", repr(item))
            if key is None:
                string = item
            else:
                string = key(item)
            # print("TESTED STRING", string)
            return rule.match(string)
        for rule in self._rules:
            iterable = filter(functools.partial(matcher, rule), iterable)
        return iterable

    def __repr__(self):
        return "{:s}([{}])".format(type(self).__name__,
                                   ", ".join("'{!s}'".format(r)
                                             for r in self._rules))

def is_test_case(obj):
    return isinstance(obj, type) and issubclass(obj, unittest.TestCase)

def collect_test_cases(module, filter_rules=None):
    if filter_rules is None:
        filter_rules = FilterRules()
    return filter_rules(filter(is_test_case,
                               map(lambda x: getattr(module, x),
                                   dir(module))),
                        key=functools.partial(build_test_name, module))

def is_test_method(name):
    return re.match(r"^test_", name)

def collect_test_names(test_case, filter_rules=None):
    if filter_rules is None:
        filter_rules = FilterRules()
    return filter_rules(map(functools.partial(getattr, test_case),
                            filter(is_test_method, dir(test_case))),
                        key=functools.partial(build_test_name,
                                              test_case.__module__,
                                              test_case))

def build_test_name(test_module, test_case=None, test_method=None):
    l = [test_module]
    if test_case is not None:
        l.append(test_case)
    if test_method is not None:
        l.append(test_method)
    def transform(x):
        if hasattr(x, "__name__"):
            return x.__name__
        else:
            return x
    return pyname_join(map(transform, l))

def collect_all_test_modules(package, pattern):
    directory = os.path.dirname(package.__file__)
    assert directory.startswith(os.getcwd())
    # We cannot use the finder to load the module because it mess up unittest.
    # Using import_module() is fine.
    for finder, name, ispkg in pkgutil.walk_packages(path=[directory]):
        if ispkg:
            fullname = pyname_join((package.__name__, name))
            mod = import_module(fullname)
            yield from collect_all_test_modules(mod, pattern)
        else:
            if re.match(pattern, name):
                fullname = pyname_join((package.__name__, name))
                mod = import_module(fullname)
                yield mod

class TestSpecType(Enum):
    package = 1
    module = 2
    test_case = 3
    test_method = 4

def is_pkg(mod):
    return os.path.basename(mod.__file__) == "__init__.py"

class InvalidTestSpecError(Exception):

    def __init__(self, test_spec, message):
        self.test_spec = test_spec
        self.message = message

    def __str__(self):
        return "invalid test spec '{}': {}".format(self.test_spec,
                                                   self.message)

def get_test_spec_type(test_spec):
    if not test_spec:
        raise ValueError("empty test spec")
    if isinstance(test_spec, str):
        spec = test_spec.split(".")
    elif isinstance(test_spec, (list, tuple)):
        spec = test_spec
        test_spec = pyname_join(spec)
    else:
        raise TypeError("must be a str, list or tuple, not {!r}"
                        .format(type(test_spec).__name__))
    assert len(spec) > 0
    mod = None
    for i in range(len(spec)-1, -1, -1):
        try:
            mod = import_module(pyname_join(spec[:i+1]))
        except ImportError:
            pass
        else:
            break
    if mod is None:
        raise InvalidTestSpecError(test_spec, "failed to import anything")
    if not os.path.dirname(mod.__file__).startswith(os.getcwd()):
        raise InvalidTestSpecError(
            test_spec,
            "package or module '{}' refers outside of your current directory "
            "you should set PYTHONPATH=.".format(mod.__name__))
    mods = spec[:i+1]
    attrs = spec[i+1:]
    if not attrs:
        if is_pkg(mod): # Package
            return (TestSpecType.package, mod)
        else: # module
            return (TestSpecType.module, mod)
    else:
        obj = mod
        for i in range(len(attrs)):
            attr = attrs[i]
            try:
                obj = getattr(obj, attr)
            except AttributeError:
                raise InvalidTestSpecError(
                    test_spec,
                    "cannot get attribute '{}' from '{}'"
                    .format(attr, pyname_join(mods+attrs[:i])))
        if is_test_case(obj):
            return (TestSpecType.test_case, obj)
        else:
            return (TestSpecType.test_method, obj)

def collect_all_from_test_case(test_case):
    for test_method in collect_test_names(test_case):
        yield build_test_name(test_case.__module__, test_case, test_method)

def collect_all_from_module(test_module):
    for test_case in collect_test_cases(test_module):
        yield from collect_all_from_test_case(test_case)

def collect_all_from_package(package, pattern):
    for test_module in collect_all_test_modules(package, pattern):
        yield from collect_all_from_module(test_module)

def collect_all(test_specs, pattern):
    for test_spec in test_specs:
        tst, value = get_test_spec_type(test_spec)
        if tst is TestSpecType.package:
            yield from collect_all_from_package(value, pattern)
        elif tst is TestSpecType.module:
            yield from collect_all_from_module(value)
        elif tst is TestSpecType.test_case:
            yield from collect_all_from_test_case(value)
        elif tst is TestSpecType.test_method:
            yield pyname_join((value.__module__, value.__qualname__))
        else:
            raise RuntimeError("unsupported test spec type: {}"
                               .format(tst))

def reported_collect(printer, test_specs, pattern, filter_rules):
    collection = collect_all(test_specs, pattern)
    test_names = []
    for n, test_name in enumerate(filter_rules(collection)):
        printer.overwrite("collecting {:d}: {}"
                          .format(n+1, test_name))
        test_names.append(test_name)
    if len(test_names) == 0:
        printer.overwrite("no test collected")
    else:
        printer.overwrite("collected {:d} test(s)".format(len(test_names)))
    return test_names

def is_pkgdir(dirpath):
    return os.path.isdir(dirpath) \
        and os.path.isfile(os.path.join(dirpath, "__init__.py"))

def get_current_packages():
    for name in os.listdir("."):
        if is_pkgdir(name):
            yield name

def collect_from_test_suite(test_suite):
    """Generate all test full names in *test_suite* recursively.
    """
    def rec(test_suite):
        for t in test_suite:
            if isinstance(t, unittest.TestSuite):
                yield from rec(t._tests)
            elif isinstance(t, unittest.TestCase):
                yield pyname_join((t.__module__,
                                   t.__class__.__name__,
                                   t._testMethodName))
            else:
                raise RuntimeError("do not know what to do with {!r}".format(t))
    if not isinstance(test_suite, unittest.TestSuite):
        raise TypeError("must be a unittest.TestSuite, not {}"
                        .format(type(test_suite).__name__))
    yield from rec(test_suite)

def mod_split(modname):
    mo = re.match(r"^(.+)\.(.*)$", modname)
    if not mo:
        raise ValueError("invalid python path identifier")
    return (mo.group(1), mo.group(2))

def argcomplete_directories(prefix):
    for directory in get_current_packages():
        if directory.startswith(prefix):
            yield directory

def argcomplete_modules(package, pattern, prefix):
    directory = os.path.dirname(package.__file__)
    for _, name, ispkg in pkgutil.iter_modules(path=[directory]):
        if not name.startswith(prefix):
            continue
        if ispkg or re.match(pattern, name):
            fullname = pyname_join((package.__name__, name))
            yield fullname

def argcomplete_test_cases(module, prefix):
    for test_case in collect_test_cases(module):
        name = test_case.__name__
        if name.startswith(prefix):
            yield pyname_join((module.__name__, name))

def argcomplete_test_methods(test_case, prefix):
    for test_method in collect_test_names(test_case):
        name = test_method.__name__
        if name.startswith(prefix):
            yield pyname_join((test_case.__module__,
                               test_case.__name__,
                               name))

def is_empty_generator(generator):
    try:
        next(generator)
    except StopIteration:
        return True
    else:
        return False

def gen_test_spec_completion(prefix, parsed_args):
    spec = prefix.split(".")
    assert len(spec) > 0
    if len(spec) == 1:
        yield from argcomplete_directories(spec[0])
    else:
        test_spec = spec[:-1]
        rest = spec[-1]
        tst, obj = get_test_spec_type(test_spec)
        if tst is TestSpecType.package:
            yield from argcomplete_modules(obj, parsed_args.pattern, rest)
        elif tst is TestSpecType.module:
            yield from argcomplete_test_cases(obj, rest)
        elif tst is TestSpecType.test_case:
            yield from argcomplete_test_methods(obj, rest)
        elif tst is TestSpecType.test_method:
            pass # nothing to complete
        else:
            raise RuntimeError("unsupported test spec type: {}"
                               .format(tst))

def with_next_completion(completion, parsed_args):
    yield completion
    next_completion = completion + "."
    next_completions = gen_test_spec_completion(next_completion, parsed_args)
    if not is_empty_generator(next_completions):
        yield next_completion

def test_spec_completer(prefix, parsed_args, **kwargs):
    completions = gen_test_spec_completion(prefix, parsed_args)
    for n, completion in enumerate(completions):
        yield from with_next_completion(completion, parsed_args)

class PatternType(Enum):
    glob = 1
    regex = 2

def pattern_from_string(pattern_type, string):
    if pattern_type is PatternType.glob:
        return fnmatch.translate(string)
    elif pattern_type is PatternType.regex:
        return string
    else:
        raise ValueError("unsupported pattern type: {}".format(pattern_type))

class FilterAction(argparse.Action):

    DEST = "filter_rules"

    def __init__(self, option_strings, dest, nargs=None,
                 filter_rule_operator=None, pattern_type=None,
                 **kwargs):
        if nargs is not None:
            raise ValueError("nargs not allowed")
        if filter_rule_operator is None:
            raise ValueError("filter_rule_operator must be set")
        if not isinstance(filter_rule_operator, RuleOperator):
            raise TypeError("must be a rule operator, not {!r}"
                            .format(type(rule_operator).__name__))
        self.rule_operator = filter_rule_operator
        if pattern_type is None:
            raise ValueError("pattern_type must be set")
        if not isinstance(pattern_type, PatternType):
            raise TypeError("must be a pattern type, not {!r}"
                            .format(type(pattern_type).__name__))
        self.pattern_type = pattern_type
        super(FilterAction, self).__init__(option_strings,
                                           self.DEST,
                                           **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        filter_rules = getattr(namespace, self.DEST)
        if filter_rules is None:
            filter_rules = FilterRules()
            setattr(namespace, self.DEST, filter_rules)
        pattern = pattern_from_string(self.pattern_type, values)
        filter_rules.append(Rule(self.rule_operator, pattern))

def complete_arg(arg, completer):
    if ARGCOMPLETE_ENABLED:
        arg.completer = completer
    return arg

EPILOG = \
"""
Copyright (c) 2015, Nicolas Desprès
All rights reserved.
"""

def git_describe(cwd="."):
    """Return the description of this repository.

    This function use git-describe(1) because the features is not available
    in pygit2 version 0.22.0.
    """
    # TODO(Nicolas Despres): Use pygit2 ASAP.
    cmd = ["git", "describe", "--always", "--dirty", "--match", "v*"]
    description = subprocess.check_output(cmd, cwd=cwd)
    return description.decode().strip()

def get_version():
    return git_describe(cwd=os.path.dirname(os.path.realpath(__file__)))

def build_cli():
    parser = argparse.ArgumentParser(
        description=__doc__,
        epilog=dedent(EPILOG),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Disable smart terminal output.")
    parser.add_argument(
        "-p", "--pattern",
        action="store",
        default=r"^test_",
        help="Only module name matching this pattern gets collected")
    parser.add_argument(
        "-e", "--exclude",
        metavar="GLOB_PATTERN",
        action=FilterAction,
        filter_rule_operator=RuleOperator.exclude,
        pattern_type=PatternType.glob,
        help="Add an exclude glob pattern filter rule.")
    parser.add_argument(
        "-i", "--include",
        metavar="GLOB_PATTERN",
        action=FilterAction,
        filter_rule_operator=RuleOperator.include,
        pattern_type=PatternType.glob,
        help="Add an include glob pattern filter rule.")
    parser.add_argument(
        "--re",
        metavar="REGEX_PATTERN",
        action=FilterAction,
        filter_rule_operator=RuleOperator.exclude,
        pattern_type=PatternType.regex,
        help="Add an exclude regex pattern filter rule.")
    parser.add_argument(
        "--ri",
        metavar="REGEX_PATTERN",
        action=FilterAction,
        filter_rule_operator=RuleOperator.include,
        pattern_type=PatternType.regex,
        help="Add an include regex pattern filter rule.")
    parser.add_argument(
        "-c", "--collect-only",
        action="store_true",
        help="Only collect test (do not run anything).")
    parser.add_argument(
        "--version",
        action="store_true",
        help="Print version information and exit")
    arg = parser.add_argument(
        "test_specs",
        action="store",
        nargs=argparse.REMAINDER,
        default=None,
        help="Test directory/module/TestCase/test_method.")
    complete_arg(arg, test_spec_completer)
    return parser

def main(argv):
    # Patch sys.path with current directory otherwise import_module get
    # confused.
    cwd = os.getcwd()
    if cwd not in sys.path:
        sys.path.insert(0, cwd)
    cli = build_cli()
    if ARGCOMPLETE_ENABLED:
        argcomplete.autocomplete(cli)
    options = cli.parse_args(argv[1:])
    if options.version:
        print(get_version())
        return 0
    filter_rules = options.filter_rules
    if filter_rules is None:
        filter_rules = FilterRules()
    test_specs = options.test_specs
    if not test_specs:
        test_specs = list(get_current_packages())
    isatty = False if options.verbose else None
    printer = LinePrinter(isatty=isatty)
    test_names = reported_collect(printer, test_specs, options.pattern,
                                  filter_rules)
    if options.collect_only:
        printer.new_line()
        return 0
    test_suite = unittest.defaultTestLoader.loadTestsFromNames(test_names)
    result = HTestResult(printer, len(test_names))
    test_suite.run(result)
    result.print_summary()
    printer.new_line()
    return 0 if result.wasSuccessful() else 1

if __name__ == "__main__":
    sys.exit(main(sys.argv))
