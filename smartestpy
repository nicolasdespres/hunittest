#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
"""Smart unit test display.
"""


import sys
import argparse
import os
import pkgutil
import re
from importlib import import_module
import unittest
from operator import attrgetter
from pprint import pprint
import time
from datetime import datetime
import traceback

# TODO(Nicolas Despres): argcomplete should be optional
import argcomplete

# For debugging argcompleter
SMARTESTPY_DEBUG_ARGCOMPLETE = os.environ.get("SMARTESTPY_DEBUG_ARGCOMPLETE")
def log_argcomplete(*args):
    if not SMARTESTPY_DEBUG_ARGCOMPLETE:
        return
    with open("/tmp/argcomplete.log", "a") as stream:
        stream.write(" ".join(str(arg) for arg in args))
        stream.write("\n")

try:
    from colorama import Fore
except ImportError:
    sys.stderr.write("info: you can get color by install 'colorama'\n")
    class Fore(object):
        BLACK = ""
        RED = ""
        GREEN = ""
        YELLOW = ""
        BLUE = ""
        MAGENTA = ""
        CYAN = ""
        WHITE = ""
        RESET = ""

def strip_ansi_escape(string):
    return re.subn(r'\x1b.*?m', "", string)[0]

class LinePrinter(object):
    """Robust line overwriting in terminal.

    To show progress of a task on the terminal it is useful to be able to
    overwrite the previous line (using the carriage return special character).
    This way we can report a task progress in
    live without printing many lines on the terminal. Doing so, some artifact
    may appears if we are overwriting a long previous line by a shorter one
    (the end of the previous line may not be erased). This class mainly takes
    care of that. In addition it does not overwrite a line by exactly the
    same one to prevent useless refresh of the terminal. Finally, it adjusts
    its output when not printing to a terminal (e.g. a file). When using
    this object your message should not contains the "\\r" or "\\n" character,
    since it may cause confusion. Instead you should use the provided methods.
    """

    def __init__(self, output=sys.stdout, isatty=None, quiet=False):
        self.output = output
        self.isatty = self._isatty_output() if isatty is None else isatty
        self.quiet = quiet
        self.reset()

    def _isatty_output(self):
        try:
            fileno = self.output.fileno()
        except:
            return False
        else:
            return os.isatty(fileno)

    def reset(self):
        self.prev_line = None

    def write(self, string):
        if self.quiet:
            return
        self.output.write(string)

    def write_nl(self, line):
        self.write(line)
        self.new_line()

    def new_line(self):
        self.write("\n")
        self.reset()

    def overwrite(self, line):
        # Do nothing if the line has not changed.
        if self.prev_line is not None and self.prev_line == line:
            return
        if self.isatty:
            self.write("\r")
        self.write(line)
        if not self.isatty:
            self.write("\n")
        if self.isatty and self.prev_line is not None:
            len_line = len(strip_ansi_escape(line))
            len_prev_line = len(strip_ansi_escape(self.prev_line))
            if len_line < len_prev_line:
                self.write(" " * (len_prev_line - len_line))
        self.prev_line = line
        self.output.flush()

    def overwrite_nl(self, line):
        self.overwrite(line)
        self.new_line()

class StopWatch(object):

    def __init__(self):
        self.reset()

    def reset(self):
        self._started_at = None
        self._last_laps_time = None
        self._last_laps_at = None
        self._total_time = 0
        self._tick_count = 0

    @property
    def started_at(self):
        return self._started_at

    def start(self):
        self._started_at = datetime.utcnow()

    def tick(self):
        self._last_laps_at = datetime.utcnow()
        self._last_laps_time = self._last_laps_at - self._started_at
        self._total_time += self._last_laps_time.microseconds
        self._tick_count += 1

    @property
    def mean_laps_time(self):
        """Return mean laps time in microseconds."""
        return self._total_time / self._tick_count

    @property
    def last_laps_time(self):
        return self._last_laps_time

class SmartTestResult(unittest.TestResult):

    SUCCESS_COLOR = Fore.GREEN
    FAILURE_COLOR = Fore.RED
    SKIP_COLOR = Fore.BLUE
    EXPECTED_FAILURE_COLOR = Fore.YELLOW
    UNEXPECTED_SUCCESS_COLOR = Fore.CYAN
    ERROR_COLOR = Fore.MAGENTA

    ALL_STATUS = "success failure error skip expected_failure "\
                 "unexpected_success".split()

    @staticmethod
    def status_counter_name(status):
        return "_{}_count".format(status)

    def __init__(self, printer, total_tests):
        super(SmartTestResult, self).__init__()
        self._printer = printer
        self._total_tests = total_tests
        for status in self.ALL_STATUS:
            self._set_status_counter(status, 0)
        self._stopwatch = StopWatch()

    @property
    def total_tests(self):
        return self._total_tests

    @property
    def progress(self):
        return self.testsRun / self._total_tests

    @property
    def success_count(self):
        return self._success_count

    @property
    def failure_count(self):
        return self._failure_count

    @property
    def skip_count(self):
        return self._skip_count

    @property
    def expected_failure(self):
        return self._expected_failure_count

    @property
    def unexpected_success(self):
        return self._unexpected_success_count

    @property
    def error_count(self):
        return self._error_count

    def full_test_name(self, test):
        # pprint(dir(test))
        return ".".join((
            test.__module__,
            type(test).__name__,
            test._testMethodName,
        ))

    def status_color(self, status):
        return getattr(self, "{}_COLOR".format(status.upper()))

    def get_status_counter(self, status):
        return getattr(self, self.status_counter_name(status))

    def _set_status_counter(self, status, value):
        setattr(self, self.status_counter_name(status), value)

    def _inc_status_counter(self, status, inc=1):
        v = self.get_status_counter(status)
        self._set_status_counter(status, v+inc)

    def format_test_status(self, status, aligned=True):
        if status == "unexpected_success":
            msg = "~SUCCESS"
        elif status == "expected_failure":
            msg = "~FAILURE"
        else:
            msg = status.upper()
        if aligned:
            formatter = "{:^8}"
        else:
            formatter = "{}"
        return self.status_color(status) \
            + formatter.format(msg) \
            + Fore.RESET

    def _print_message(self, test, test_status, err=None, reason=None):
        self._stopwatch.tick()
        counters = {}
        counter_formats = []
        for status in self.ALL_STATUS:
            counters[status] = self.status_color(status) \
                               + str(self.get_status_counter(status)) \
                               + Fore.RESET
            counter_formats.append("{{{s}}}".format(s=status))
        formatter = "[{progress:>4.0%}|{mean_time:.2f}|" \
                    + "|".join(f for f in counter_formats) \
                    + "] {test_status}: {fullname} ({elapsed})"
        msg = formatter.format(
            progress=self.progress,
            fullname=self.full_test_name(test),
            test_status=self.format_test_status(test_status),
            elapsed=self._stopwatch.last_laps_time,
            mean_time=self._stopwatch.mean_laps_time / 1000,
            **counters)
        self._inc_status_counter(test_status)
        self._printer.overwrite(msg)
        if err is not None:
            self._print_error(test, test_status, err)
        if reason is not None:
            self._print_reason(test, test_status, reason)

    def _print_error(self, test, test_status, err):
        assert err is not None
        hbar_len = len(strip_ansi_escape(self._printer.prev_line))
        msg = "{test_status}: {fullname}"\
            .format(test_status=self.format_test_status(test_status,
                                                        aligned=False),
                    fullname=self.full_test_name(test))
        hbar_len = len(strip_ansi_escape(msg))
        self._printer.overwrite_nl("-" * hbar_len)
        self._printer.overwrite_nl(msg)
        self._printer.write_nl("-" * hbar_len)
        for lines in traceback.format_exception(*err):
            for line in lines.splitlines():
                self._printer.write_nl(line)

    def _print_reason(self, test, test_status, reason):
        msg = "{test_status}: {fullname}: {reason}"\
            .format(test_status=self.format_test_status(test_status,
                                                        aligned=False),
                    fullname=self.full_test_name(test),
                    reason=reason)
        # self._printer.new_line()
        self._printer.overwrite_nl(msg)

    def startTest(self, test):
        super(SmartTestResult, self).startTest(test)
        # print("startTest", repr(test), test.__class__, test._testMethodName)
        self._stopwatch.start()

    def stopTest(self, test):
        super(SmartTestResult, self).stopTest(test)
        # print("stopTest", repr(test))

    def startTestRun(self):
        super(SmartTestResult, self).startTestRun()
        # print("startTestRun")

    def stopTestRun(self):
        super(SmartTestResult, self).stopTestRun()
        # print("stopTesRun")

    def addSuccess(self, test):
        super(SmartTestResult, self).addSuccess(test)
        # print("addSuccess", repr(test))
        self._print_message(test, "success")

    def addFailure(self, test, err):
        super(SmartTestResult, self).addFailure(test, err)
        # print("addFailure", repr(test), repr(err))
        self._print_message(test, "failure", err=err)

    def addError(self, test, err):
        super(SmartTestResult, self).addError(test, err)
        # print("addError", repr(test), repr(err))
        self._print_message(test, "error", err=err)

    def addSkip(self, test, reason):
        super(SmartTestResult, self).addSkip(test, reason)
        self._print_message(test, "skip", reason=reason)

    def addExpectedFailure(self, test, err):
        super(SmartTestResult, self).addExpectedFailure(test, reason)
        self._print_message(test, "expected_failure")

    def addUnexpectedSuccess(self, test):
        super(SmartTestResult, self).addUnexpectedFailure(test)
        self._print_message(test, "unexpected_success")

def collect_test_modules(directory, pattern):
    for _, name, ispkg in pkgutil.walk_packages(path=[directory]):
        if not ispkg and re.match(pattern, name):
            modname = "{}.{}".format(os.path.basename(directory), name)
            mod = import_module(modname)
            yield mod

def is_test_case(obj):
    return isinstance(obj, type) and issubclass(obj, unittest.TestCase)

def collect_test_cases(module):
    return filter(is_test_case,
                  map(lambda x: getattr(module, x),
                      dir(module)))

def is_test_method(name):
    return re.match(r"^test_", name)

def collect_test_names(test_case):
    return map(lambda x: getattr(test_case, x),
               filter(is_test_method, dir(test_case)))

def build_test_name(test_module, test_case=None, test_method=None):
    l = [test_module]
    if test_case is not None:
        l.append(test_case)
    if test_method is not None:
        l.append(test_method)
    return ".".join(map(attrgetter("__name__"), l))

def select(name, includes=None):
    if includes is None:
        includes = []
    for prefix in includes:
        if name.startswith(prefix):
            yield name

def collect(directories, pattern, yield_group=False, includes=None):
    for directory in directories:
        for test_module in collect_test_modules(directory, pattern=pattern):
            if yield_group:
                yield from select(build_test_name(test_module), includes)
            for test_case in collect_test_cases(test_module):
                if yield_group:
                    yield from select(build_test_name(test_module, test_case),
                                      includes)
                for test_method in collect_test_names(test_case):
                    yield from select(build_test_name(test_module,
                                                      test_case,
                                                      test_method),
                                      includes)

def reported_collect(printer, directories, pattern, includes=None):
    test_names = []
    for n, test_name in enumerate(collect(directories, pattern,
                                          yield_group=False,
                                          includes=includes)):
        printer.overwrite("collecting {:d}: {}"
                          .format(n+1, test_name))
        test_names.append(test_name)
    printer.overwrite_nl("collected {:d} test(s)".format(len(test_names)))
    return test_names

def collect_directories(options):
    if not options.directories:
        for default_test_dir in ("test", "tests"):
            if os.path.isdir(default_test_dir):
                yield default_test_dir
    else:
        for test_dir in options.directories:
            yield test_dir

def test_name_completer(prefix, parsed_args, **kwargs):
    return collect(collect_directories(parsed_args),
                   parsed_args.pattern,
                   yield_group=True,
                   includes=[prefix])

def build_cli():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Disable smart terminal output.")
    parser.add_argument(
        "-p", "--pattern",
        action="store",
        default=r"^test_",
        help="Only module name matching this pattern gets collected")
    parser.add_argument(
        "-d", "--directory",
        action="append",
        dest="directories",
        metavar="DIRECTORY",
        default=[],
        help="Directory where to look for test (can be used multiple times).")
    parser.add_argument(
        "test_names",
        action="store",
        nargs=argparse.REMAINDER,
        default=None,
        help="Name of test to run.").completer = test_name_completer
    return parser

def main(argv):
    cli = build_cli()
    argcomplete.autocomplete(cli)
    options = cli.parse_args(argv[1:])
    directories = collect_directories(options)
    isatty = False if options.verbose else None
    printer = LinePrinter(isatty=isatty)
    test_names = reported_collect(printer, directories, options.pattern,
                                  includes=options.test_names)
    test_suite = unittest.defaultTestLoader.loadTestsFromNames(test_names)
    result = SmartTestResult(printer, len(test_names))
    test_suite.run(result)
    printer.new_line()
    return 0 if result.wasSuccessful() else 1

if __name__ == "__main__":
    sys.exit(main(sys.argv))
